# 📌 RISC-V RV32I CPU 설계 프로젝트

## 📜 목차 (Table of Contents)

1.  [**프로젝트 개요**](#-프로젝트-개요)
2.  [**주요 특징**](#-주요-특징)
3.  [**프로젝트 구조**](#-프로젝트-구조)
4.  [**개발 환경**](#-개발-환경)
5.  [**CPU 아키텍처**](#-cpu-아키텍처)
6.  [**검증 및 시뮬레이션**](#-검증-및-시뮬레이션)
7.  [**C언어 프로그램 테스트**](#-c언어-프로그램-테스트)
8.  [**실행 방법**](#-실행-방법)
9.  [**문제 해결 과정**](#-문제-해결-과정)
10. [**느낀 점 및 회고**](#-느낀-점-및-회고)

## 🎯 프로젝트 개요

RISC-V 명령어 세트 아키텍처(ISA)를 기반으로 구현한 32비트 CPU 설계 프로젝트입니다. CPU의 핵심 구성 요소인 **데이터 경로(DataPath)**와 **제어 유닛(Control Unit)**을 System Verilog를 사용하여 설계하고 Vivado tool을 활용하여 RTL 코드를 합성하고 시뮬레이션을 통해 모든 명령어 타입의 동작을 검증하고자 했습니다.

---

## ✨ 주요 특징

- **Multi-Cycle 아키텍처**: 각 명령어를 여러 단계로 나누어 실행하는 Multi-Cycle 방식으로 설계하여, 클록 주기를 효율적으로 설정하고 하드웨어 자원 활용도를 높였습니다.
- **RV32I 명령어 세트 완벽 구현**: 모든 종류의 명령어를 처리할 수 있도록 설계되었습니다.
    - **R-Type** (레지스터-레지스터 연산)
    - **I-Type** (단축된 상수값 연산)
    - **S-Type** (메모리 저장)
    - **B-Type** (조건부 분기)
    - **L-Type** (메모리 로드)
    - **U-Type** (긴 상수값 로드)
    - **J-Type** (무조건 점프)
- **소프트웨어-하드웨어 연계 검증**: C언어로 작성된 코드를 RISC-V 기계어로 변환하여 실제 CPU에서 실행함으로써, 설계된 하드웨어의 실용성을 확인했습니다.

---

## 📂 프로젝트 구조
```
CPU-Design/
├── docs/           # 설계 보고서, 참고 자료
├── rtl/            # Verilog/SystemVerilog RTL 코드
│   ├── single/     # Single-Cycle CPU
│   ├── multi/      # Multi-Cycle CPU
│   └── common/     # 공용 모듈(ALU, Register File 등)
├── tb/             # Testbench 코드
├── sim/            # 시뮬레이션 스크립트 및 결과
└── README.md
```

---

## 💻 개발 환경

- **EDA**: Xilinx **Vivado HLx Editions**
- **언어 (Language)**: **Verilog HDL**
- **IDE**: **Visual Studio Code**

---

## 🏗️ CPU 아키텍처

### Control Unit 상태도

CPU의 모든 동작을 제어하는 Control Unit은 명령어의 종류에 따라 상태를 전환하며 데이터 경로를 제어합니다. 명령어 Fetch 및 Decode 후, 각 명령어 타입에 맞는 Execute 상태로 분기합니다.

[여기에 Control Unit 상태도 이미지를 삽입하세요 (PDF 6페이지)]

### 명령어별 데이터 경로

| **R-Type** | **I-Type** | **L-Type** |
| :------------------------------------------------------: | :-------------------------------------------------------: | :-------------------------------------------------------: |
| [R-Type 블록 다이어그램 이미지 (PDF 7페이지)] | [I-Type 블록 다이어그램 이미지 (PDF 16페이지)] | [L-Type 블록 다이어그램 이미지 (PDF 10페이지)] |
| **S-Type** | **B-Type** | **J-Type** |
| [S-Type 블록 다이어그램 이미지 (PDF 13페이지)] | [B-Type 블록 다이어그램 이미지 (PDF 19페이지)] | [J-Type 블록 다이어그램 이미지 (PDF 26페이지)] |

---

## 🔬 검증 및 시뮬레이션

### 테스트벤치 전략
정확한 기능 검증을 위해 체계적인 테스트벤치를 구축했습니다.
* **Task 기반 검증**: `reset_cpu`, `check_result_RF`, `check_result_DMEM` 등 반복적인 작업을 Task로 모듈화하여 테스트 효율을 높였습니다
* **매크로 경로 설정**: `define`을 사용하여 주요 모듈의 계층적 경로를 상수로 정의하여 코드의 가독성과 유지보수성을 향상시켰습니다.
* **Timeout 기능**: 지정된 시간 내에 테스트가 완료되지 않으면 시뮬레이션을 자동으로 종료시키는 로직을 추가하여 무한 루프 등의 오류를 방지했습니다.

---

### 시뮬레이션 결과

| 명령어 타입           | 시뮬레이션 파형                                      |
| :-------------------- | :--------------------------------------------------- |
| **R-Type** | [R-Type 시뮬레이션 파형 이미지 (PDF 9페이지)]      |
| **I-Type** | [I-Type 시뮬레이션 파형 이미지 (PDF 18페이지)]     |
| **L-Type** | [L-Type 시뮬레이션 파형 이미지 (PDF 12페이지)]     |
| **S-Type** | [S-Type 시뮬레이션 파형 이미지 (PDF 15페이지)]     |
| **B-Type** | [B-Type 시뮬레이션 파형 이미지 (PDF 21페이지)]     |
| **U-Type (LUI&AUIPC)** | [LU/AU-Type 시뮬레이션 파형 이미지 (PDF 25페이지)] |
| **J-Type (JAL&JALR)** | [J/JL-Type 시뮬레이션 파형 이미지 (PDF 28, 31페이지)] |

---

## 🔄 C언어 프로그램 테스트

설계된 CPU의 실제 동작을 검증하기 위해 간단한 C언어 프로그램을 컴파일하여 테스트를 진행했습니다. `main` 함수에서 `add` 함수를 호출하여 `3 + 5` 연산을 수행하는 코드를 사용했으며, 시뮬레이션을 통해 최종 결과값 `8`이 레지스터에 정확히 저장됨을 확인했습니다.

### 컴파일 환경
-   **Toolchain**: RISC-V GNU Compiler Toolchain
-   **Commands**:
    ```bash
    riscv64-unknown-elf-gcc -o test.o -c test.c -march=rv32i
    riscv64-unknown-elf-objcopy -O binary test.o test.bin
    ```
---

## 🛠️ 문제 해결 과정

**S-Type 명령어 처리 로직 개선**

- **문제점**: S-Type 명령어(`sh`, `sb`) 처리 시, 데이터 경로에서는 이미 `Byte_Enable`을 고려하여 32비트로 정렬된 쓰기 데이터(`BE_WData`)를 생성하고 있었습니다. 하지만 RAM 모듈에서 `Byte_Enable` 신호를 받아 부분 쓰기(partial write)를 수행하는 중복 로직이 존재했습니다.
- **해결책**: 데이터 경로에서 이미 정렬된 데이터를 보내주므로, RAM에서는 `Byte_Enable` 없이 32비트 `wData`를 그대로 쓰는 방식으로 단순화했습니다.
- **개선 효과**: 불필요한 제어 신호를 제거하여 데이터 경로를 단순화하고 설계 효율성을 향상시켰습니다.

---

## 🧠 느낀 점 및 회고

- **소프트웨어와 하드웨어의 연결고리 이해**: C언어 코드가 어셈블리어와 기계어로 변환되는 과정을 직접 수행하며, 추상적인 고급 언어의 연산이 하드웨어에서 어떻게 구체적인 명령어로 실행되는지 명확히 파악할 수 있었습니다.
- **CPU 아키텍처 설계 방식에 대한 고찰**: Multi-Cycle 방식은 제어가 복잡하지만 하드웨어 자원을 효율적으로 사용하여 성능을 높일 수 있다는 점을 확인했습니다. 학습 목적과 실제 구현 효율을 고려한 아키텍처 선택의 중요성을 배울 수 있었습니다.

---

## 📚 향후 발전

```
Pipeline CPU 설계
Hazard 제어 (Forwarding, Stall, Branch Prediction)
```